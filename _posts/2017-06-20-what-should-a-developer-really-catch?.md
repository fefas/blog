---
layout: post
permalink: /posts/:title

title: What should a developer really catch?

mediumUri: not-yet-created
---
# What should a developer really catch?

In my first post I would like to write about something that isn't found so often
on the internet and most ~~experienced~~ developers are missing.

Maybe because they seem to worry more about _tech-hacks_ than realistic
professionalism, that is my guess.

First of all, I would like to say that this post is both something I have to
vent out and a self-critique.

## What are we, developers?

Stop it! Let's bring something up: _when we write code, we write solutions... or
that's what we're supposed to do._

No, we aren't coding the next ~~magic~~ wonderful architecture. We SHOULD just
translate business solutions to a code language that SHOULD solve business
problems by adding some value somehow and it SHOULD be delivered in the simplest
and fastest possible way. But we don't!

> _"We are unprofessional"_, Robert Martin already said that.

In my short career I've seen more than once smart developers having the
opportunity to work on an outstanding business model and using that business
complexity as their motivation to build nice, sophisticated and high-tech
applications which, as it turned out, ~~helped the company grow up~~ were just
another group of hard-to-understand words and far far away from the business
itself. In other words, a waste of time and money resulting in a code that is
already legacy at the first day after deployment. A total mess!

![Total Mess](/assets/images/posts/2017-06-20-what-should-a-developer-really-catch%3F-total-mess.jpg)

What I am trying to put in words is strictly related to the professional
attitude of a software developer. You are never going to be a respected CTO or
even a senior if you don't give a damn to the next people that will continue the
work; the next person can always be you again and again...

We have to face the truth by caring about how our current code will help the
next developer in maintaining it. When we go a little deeper, we should ask
_why, what, how_ before coding anything. We have to know the way our work is
going to impact the users. Understanding the final users and the business
requirements is a critical gap between good and bad code.

If a developer doesn't have those concerns in mind, he is writing a bunch of
lines that don't make sense together and, instead of improving users'
experience, the growing mess isn't adding any value... the company may go out of
business quickly.

> Just to be clear here: when I say good code I mean _expressive_ code, not an
> agglomeration of design patterns. Good code is simple and direct.

## Where is our the problem then?

This could be an endless discussion. So, I selected only two of my guesses I
judge being the most critical ones.

Many developers, just like me, didn’t pursue software-related degree at
university. Actually, some of us didn't even go to college; and those who took
software-related courses realized they didn't know exactly what is required to
solve real problems. In other words, we teach ourselves almost everything by
digging the internet.

That proves we are extremely self-motivated and curious. Indeed, we really enjoy
to learn more and more. The problem is that the internet has so much information
that the beginners **end up placing so much importance on what gives short-term
results**, that is tools.

Programming languages, frameworks, libraries and so on are important and make
you feel powerful, but they all are **still just tools**.

A very important point to observe in tools is when you stop to follow that nice
framework for a couple of months and then you are suddenly out of date. But
don't bother! You can read the new documentation and update yourself again
quickly. Tools are ephemeral, easy to learn, abundant on the web and, trust me,
most of them don't give a &$%! to your business domain.

On the other hand, when developers come across some new subject or tool, instead
of taking the needed time to search and really understand it before coding, they
go straight ahead and want to adopt it everywhere, because the ~~new silver
bullet~~ key was discovered. The result (not to say problem) is predictable...

For me, this kind of developer is the most dangerous, because they normally have
more work-experience and are still acting like the ninja ones. Their attitude
only brings premature and wrong use of tools, procedures and methodologies,
putting the whole business and the collaborators in risk. They have no idea
about their positions' value.

## So, what should we really study?

Years ago at university I heard someone saying:

> _"O diferencial para um bom jogador de sinuca não é conseguir matar bolas
> difíceis, sim conseguir posicionar a bola branca para a próxima tacada."_ --
> Anonymous

During the last two years I worked with great teams that introduced me to some
terms: Clean Code, Test Driven Development (TDD), Domain-Driven Design (DDD),
Behavior Driven Development (BDD), Continuous Integration (CI), DevOps, Agile
Manifesto, Software Craftsmanship etc.

I still have a lot to learn about those subjects, but they already changed my
professional attitude and today I know I am on the right way to become the
respected developer as I've always dreamed to.

Meetups and daily knowledge exchange with team members are all important to
discuss different readings about those terms, but they alone will still give you
a limited understanding. Therefore, the only way to have a deep knowledge is by
searching it by yourself through books, podcasts, events and so on.

The following books list is the main reason I wrote this post. Of course I
haven't yet read all of them, but the ones I did have changed the way I develop
every couple of pages, turning me into a **more conscious and mature
developer**:

- Pragmatic Unit Testing with JUnit in Java 8 of Jeff Langr;
- Growing Object Oriented Software, Guided by Tests (Nat Pryce, Steve Freeman);
- Design Patterns: Elements of Reusable Object-Oriented Software (Erich Gamma,
  Richard Helm, Ralph Johnson and John Vlissides Gang of Four);
- Clean Code: A Handbook of Agile Software Craftsmanship (Robert C Martin, aka
  Uncle Bob);
- Patterns of Enterprise Application Architecture (Martin Fowler);
- Touch of Class (Bertrand Meyer);
- Implementing Domain-Driven Design (Vaughn Vernon);
- Domain-Driven Design Distilled (Vaughn Vernon);
- Continuous Delivery (David Farley, Jezz Humble);
- Rest API Design Rulebook (Mark Massé);
- Release It! (Michael Nygard);
- The Scrum Guide (Ken Schwaber, Jeff Sutherland);
- Kanban in 30 days (Thomas & Jannika Bjorkholm);
- The Art of Agile Development (James Shore);
- The Software Craftsman (Sandro Mancuso);
- Running Lean (Ash Maurya).

And you can also follow the authors:

- Robert C. Martin (aka Uncle Bob);
- Kent Beck;
- Vaughn Vernon;
- Martin Fowler;
- Grady Booch;
- James Coplien;
- Eric Evans;
- Rebecca Wirfs-Brock.

> Thanks [Eriksen Costa](https://blog.eriksen.com.br). He was my boss and sent
> me both lists.

My recommendation is to start with _The Software Craftsman_.

I hope you can also find a reference to follow on those books. And remember,
**simplicity is a keyword**.

> Is there already any T-shirt with _"Don't worry and keep it simple"_?
