---
layout: post
permalink: /:title

title: Software Materialistic, what is it?
image: Total Mess
excerpt:
  In my first post I would like to write about something that isn't found so
  often on the internet and most ~~experienced~~ developers are missing.

mediumId: TODO
devtoId: TODO
---

After almost 5 years from my last techincal post, here I am again. What have I
changed? Probably not much. I am still getting amazed by the ability of
developers to create mess.

This time, however, instead of just having the similar complaning narrative of
my previous posts, I would like to bring up few key topics that help me to write
simple code that makes sense.

After all, why would someone like to write complex code?

Now some might be asking theirselves: all needed to significantly improve coding
skills is just few topics?

Well, kinda of yes, but _that does not mean it is easy_.

The approach to be followed in this series of posts is not to extensively
explain the theory, rather to present it: there are already great books out
there that are referenced as necessary (for those who already want to have a
grasp on them, take a look into [my first
post](/what-should-a-developer-really-catch).

Let's remember a quote from Sir Isaac Newton for a moment:

> "If I have seen further, it is by standing on the shoulders of giants"

# Why Materialistic?

Finally, it is also important to mention the audience the content of the
Software Materialistic series is targetting.

There is a common understanding in the industry that software developers are
architects or engineers or both. Even though I understand the argumentation
behind it, I desagree with this idea.

To explain the point, I gotta say software development is highly abstract.
Therefore, I often make usage of analogies.

While it is true huge constructions like a huge bridge extensively require
architects and engineers work, the cratfspeople are the ones that materialize
the project. Without proper materialization, any impeccably planned project will
most likely fail.

> Software developers are primary craftspeople. They do architect, but they
> mainly code.

Even if one does have the goal of becoming a sole software architect, experting
the craft of software development does not have any less importance. How would
great architects and engineers have ever been able to plan that huge bridge
without the deep konwledge of the techniques craftspeople would need to employ
during the construction?

However, the current majority of codebases status quo demostrate a huge gap
between software principles and their implementations.

Who has never had their SOLID knowledge challenged in a technical interview and
then was able to spot dozens of classes breaking Dependency Inversion princile
on their first look at the code when starting the new job?

How to tackle this problem?

My propose: let's acknowledge the fact software developers are craftpeople,
let's not only understand the theory, but also expert the techniques, let's be
materialistic.

